<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>draco.analysis.beamform &mdash; draco 0+untagged.1.ga138890 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> draco
          </a>
              <div class="version">
                0+untagged.1.ga138890
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev.html">Development Guidelines</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">draco</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>draco.analysis.beamform</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for draco.analysis.beamform</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Beamform visibilities to the location of known sources.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">healpy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">from</span> <span class="nn">skyfield.api</span> <span class="kn">import</span> <span class="n">Star</span><span class="p">,</span> <span class="n">Angle</span>

<span class="kn">from</span> <span class="nn">caput</span> <span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">caput</span> <span class="kn">import</span> <span class="n">time</span> <span class="k">as</span> <span class="n">ctime</span>

<span class="kn">from</span> <span class="nn">cora.util</span> <span class="kn">import</span> <span class="n">units</span>

<span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">task</span><span class="p">,</span> <span class="n">containers</span><span class="p">,</span> <span class="n">io</span>
<span class="kn">from</span> <span class="nn">..util._fast_tools</span> <span class="kn">import</span> <span class="n">beamform</span>
<span class="kn">from</span> <span class="nn">..util.tools</span> <span class="kn">import</span> <span class="n">baseline_vector</span><span class="p">,</span> <span class="n">polarization_map</span><span class="p">,</span> <span class="n">invert_no_zero</span>
<span class="kn">from</span> <span class="nn">..util.tools</span> <span class="kn">import</span> <span class="n">calculate_redundancy</span>

<span class="c1"># Constants</span>
<span class="n">NU21</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">nu21</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">c</span>


<div class="viewcode-block" id="BeamFormBase"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormBase">[docs]</a><span class="k">class</span> <span class="nc">BeamFormBase</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for beam forming tasks.</span>

<span class="sd">    Defines a few useful methods. Not to be used directly</span>
<span class="sd">    but as parent class for BeamForm and BeamFormCat.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    collapse_ha : bool</span>
<span class="sd">        Sum over hour-angle/time to complete the beamforming. Default is True.</span>
<span class="sd">    polarization : string</span>
<span class="sd">        Determines the polarizations that will be output:</span>
<span class="sd">            - &#39;I&#39; : Stokes I only.</span>
<span class="sd">            - &#39;full&#39; : &#39;XX&#39;, &#39;XY&#39;, &#39;YX&#39; and &#39;YY&#39; in this order. (default)</span>
<span class="sd">            - &#39;copol&#39; : &#39;XX&#39; and &#39;YY&#39; only.</span>
<span class="sd">            - &#39;stokes&#39; : &#39;I&#39;, &#39;Q&#39;, &#39;U&#39; and &#39;V&#39; in this order. Not implemented.</span>
<span class="sd">    weight : string</span>
<span class="sd">        How to weight the redundant baselines when adding:</span>
<span class="sd">            - &#39;natural&#39; : each baseline weighted by its redundancy (default)</span>
<span class="sd">            - &#39;uniform&#39; : each baseline given equal weight</span>
<span class="sd">            - &#39;inverse_variance&#39; : each baseline weighted by the weight attribute</span>
<span class="sd">    no_beam_model : string</span>
<span class="sd">        Do not include a primary beam factor in the beamforming</span>
<span class="sd">        weights, i.e., use uniform weighting as a function of hour angle</span>
<span class="sd">        and declination.</span>
<span class="sd">    timetrack : float</span>
<span class="sd">        How long (in seconds) to track sources at each side of transit.</span>
<span class="sd">        Default is 900 seconds.  Total transit time will be 2 * timetrack.</span>
<span class="sd">    variable_timetrack : bool</span>
<span class="sd">        Scale the total time to track each source by the secant of the</span>
<span class="sd">        source declination, so that all sources are tracked through</span>
<span class="sd">        the same angle on the sky.  Default is False.</span>
<span class="sd">    freqside : int</span>
<span class="sd">        Number of frequencies to process at each side of the source.</span>
<span class="sd">        Default (None) processes all frequencies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">collapse_ha</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">polarization</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="s2">&quot;copol&quot;</span><span class="p">,</span> <span class="s2">&quot;stokes&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;natural&quot;</span><span class="p">,</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;natural&quot;</span><span class="p">)</span>
    <span class="n">no_beam_model</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">timetrack</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">900.0</span><span class="p">)</span>
    <span class="n">variable_timetrack</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">freqside</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">data_available</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BeamFormBase.setup"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormBase.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generic setup method.</span>

<span class="sd">        To be complemented by specific setup methods in daughter tasks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : either `ProductManager`, `BeamTransfer` or `TransitTelescope`</span>
<span class="sd">            Contains a TransitTelescope object describing the telescope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the TransitTelescope object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>

        <span class="c1"># Polarizations.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;YX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;copol&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;stokes&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;YX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Stokes parameters are not implemented&quot;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This should never happen. config.enum should bark first.</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid polarization parameter: </span><span class="si">{0}</span><span class="s2">&quot;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polarization</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">npol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">map_pol_feed</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">pstr</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">polarisation</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pstr</span><span class="p">)</span> <span class="k">for</span> <span class="n">pstr</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="c1"># Ensure that if we are using variable time tracking,</span>
        <span class="c1"># then we are also collapsing over hour angle.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_timetrack</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Tracking source for declination dependent amount of time &quot;</span>
                    <span class="s2">&quot;[</span><span class="si">%d</span><span class="s2"> seconds at equator]&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">timetrack</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Must collapse over hour angle if tracking &quot;</span>
                    <span class="s2">&quot;sources for declination dependent &quot;</span>
                    <span class="s2">&quot;amount of time.&quot;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Tracking source for fixed amount of time [</span><span class="si">%d</span><span class="s2"> seconds]&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">timetrack</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="BeamFormBase.process"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormBase.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generic process method.</span>

<span class="sd">        Performs all the beamforming, but not the data parsing.</span>
<span class="sd">        To be complemented by specific process methods in daughter tasks.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formed_beam : `containers.FormedBeam` or `containers.FormedBeamHA`</span>
<span class="sd">            Formed beams at each source. Shape depends on parameter</span>
<span class="sd">            `collapse_ha`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Perform data dependent beam initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_beam_with_data</span><span class="p">()</span>

        <span class="c1"># Contruct containers for formed beams</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
            <span class="c1"># Container to hold the formed beams</span>
            <span class="n">formed_beam</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">(</span>
                <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">object_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;object_id&quot;</span><span class="p">],</span>
                <span class="n">pol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span><span class="p">),</span>
                <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Container to hold the formed beams</span>
            <span class="n">formed_beam</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeamHA</span><span class="p">(</span>
                <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">ha</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                <span class="n">object_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;object_id&quot;</span><span class="p">],</span>
                <span class="n">pol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span><span class="p">),</span>
                <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Initialize container to zeros.</span>
            <span class="n">formed_beam</span><span class="o">.</span><span class="n">ha</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">formed_beam</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="n">tag</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tag_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag_catalog</span><span class="p">]</span> <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Initialize container to zeros.</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy catalog information</span>
        <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span>
        <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="p">:</span>
            <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: If there is not redshift information,</span>
            <span class="c1"># should I have a different formed_beam container?</span>
            <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][</span><span class="s2">&quot;z_error&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Ensure container is distributed in frequency</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Indices of local frequency axis. Full axis if freqside is None.</span>
            <span class="n">f_local_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">f_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">fbb</span> <span class="o">=</span> <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span>
        <span class="n">fbw</span> <span class="o">=</span> <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># For each source, beamform and populate container.</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsource</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">src</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Source </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nsource</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Declination of this source</span>
            <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sdec</span><span class="p">[</span><span class="n">src</span><span class="p">])</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Get the frequency bin this source is closest to.</span>
                <span class="n">freq_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span><span class="p">[</span><span class="n">src</span><span class="p">])</span>
                <span class="n">sfreq_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">freq_diff</span><span class="p">)</span>
                <span class="c1"># Start and stop indices to process in global frequency axis</span>
                <span class="n">freq_idx0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">sfreq_index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span><span class="p">])</span>
                <span class="n">freq_idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">sfreq_index</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="c1"># Mask in full frequency axis</span>
                <span class="n">f_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">f_mask</span><span class="p">[</span><span class="n">freq_idx0</span><span class="p">:</span><span class="n">freq_idx1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># Restrict frequency mask to local range</span>
                <span class="n">f_mask</span> <span class="o">=</span> <span class="n">f_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">)]</span>

                <span class="c1"># TODO: In principle I should be able to skip</span>
                <span class="c1"># sources that have no indices to be processed</span>
                <span class="c1"># in this rank. I am getting a NaN error, however.</span>
                <span class="c1"># I may need an mpiutil.barrier() call before the</span>
                <span class="c1"># return statement.</span>
                <span class="k">if</span> <span class="n">f_mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="c1"># If there are no indices to be processed in</span>
                    <span class="c1"># the local frequency range, skip source.</span>
                    <span class="k">continue</span>

                <span class="c1"># Frequency indices to process in local range</span>
                <span class="n">f_local_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">f_mask</span><span class="p">)]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span><span class="p">:</span>
                <span class="c1"># Get RA bin this source is closest to.</span>
                <span class="c1"># Phasing will actually be done at src position.</span>
                <span class="n">sra_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">[</span><span class="n">src</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Cannot use searchsorted, because RA might not be</span>
                <span class="c1"># monotonically increasing. Slower.</span>
                <span class="c1"># Notice: in case there is more than one transit,</span>
                <span class="c1"># this will pick a single transit quasi-randomly!</span>
                <span class="n">transit_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">[</span><span class="n">src</span><span class="p">])</span>
                <span class="n">sra_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">transit_diff</span><span class="p">)</span>
                <span class="c1"># For now, skip sources that do not transit in the data</span>
                <span class="n">ra_cadence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">transit_diff</span><span class="p">[</span><span class="n">sra_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">ra_cadence</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_timetrack</span><span class="p">:</span>
                <span class="n">ha_side</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ha_side</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ha_side</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ha_side</span><span class="p">)</span>

            <span class="c1"># Compute hour angle array</span>
            <span class="n">ha_array</span><span class="p">,</span> <span class="n">ra_index_range</span><span class="p">,</span> <span class="n">ha_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ha_array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span> <span class="n">sra_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">[</span><span class="n">src</span><span class="p">],</span> <span class="n">ha_side</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span>
            <span class="p">)</span>

            <span class="c1"># Arrays to store beams and weights for this source</span>
            <span class="c1"># for all polarizations prior to combining polarizations</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                <span class="p">)</span>
                <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Loop over polarisations</span>
            <span class="k">for</span> <span class="n">pol</span><span class="p">,</span> <span class="n">pol_str</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span><span class="p">):</span>

                <span class="n">primary_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beamfunc</span><span class="p">(</span><span class="n">pol_str</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">ha_array</span><span class="p">)</span>

                <span class="c1"># Fringestop and sum over products</span>
                <span class="c1"># &#39;beamform&#39; does not normalize sum.</span>
                <span class="n">this_formed_beam</span> <span class="o">=</span> <span class="n">beamform</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="n">pol</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span><span class="p">[</span><span class="n">pol</span><span class="p">],</span>
                    <span class="n">dec</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ha_array</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ha_array</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span><span class="p">[</span><span class="n">pol</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span><span class="p">[</span><span class="n">pol</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">f_local_indices</span><span class="p">,</span>
                    <span class="n">ra_index_range</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">sumweight_inrange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span><span class="p">[</span><span class="n">pol</span><span class="p">][:,</span> <span class="n">ra_index_range</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">visweight_inrange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="p">[</span><span class="n">pol</span><span class="p">][:,</span> <span class="n">ra_index_range</span><span class="p">,</span> <span class="p">:]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                    <span class="c1"># Sum over RA. Does not multiply by weights because</span>
                    <span class="c1"># this_formed_beam was never normalized (this avoids</span>
                    <span class="c1"># re-work and makes code more efficient).</span>

                    <span class="n">this_sumweight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sumweight_inrange</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">primary_beam</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">)</span>

                    <span class="n">formed_beam_full</span><span class="p">[</span><span class="n">pol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">this_formed_beam</span> <span class="o">*</span> <span class="n">primary_beam</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">this_sumweight</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">!=</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">:</span>
                        <span class="n">this_weight2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                <span class="n">sumweight_inrange</span><span class="o">**</span><span class="mi">2</span>
                                <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">visweight_inrange</span><span class="p">),</span>
                                <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="o">*</span> <span class="n">primary_beam</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>

                        <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_sumweight</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span>
                            <span class="n">this_weight2</span>
                        <span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_sumweight</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Need to divide by weight here for proper</span>
                    <span class="c1"># normalization because it is not done in</span>
                    <span class="c1"># beamform()</span>
                    <span class="n">this_sumweight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sumweight_inrange</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># Populate only where ha_mask is true. Zero otherwise.</span>
                    <span class="n">formed_beam_full</span><span class="p">[</span><span class="n">pol</span><span class="p">][</span>
                        <span class="p">:,</span> <span class="n">ha_mask</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">this_formed_beam</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">this_sumweight</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">!=</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">:</span>
                        <span class="n">this_weight2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                            <span class="n">sumweight_inrange</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">visweight_inrange</span><span class="p">),</span>
                            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="c1"># Populate only where ha_mask is true. Zero otherwise.</span>
                        <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">][</span>
                            <span class="p">:,</span> <span class="n">ha_mask</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">this_sumweight</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">this_weight2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">][:,</span> <span class="n">ha_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_sumweight</span>

                <span class="c1"># Ensure weights are zero for non-processed frequencies</span>
                <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">][</span><span class="n">f_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Combine polarizations if needed.</span>
            <span class="c1"># TODO: For now I am ignoring differences in the X and</span>
            <span class="c1"># Y beams and just adding them as is.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
                <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">formed_beam_full</span> <span class="o">*</span> <span class="n">weight_full</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_full</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_full</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Add an axis for the polarization</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                    <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">formed_beam_full</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">))</span>
                    <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">weight_full</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="n">formed_beam_full</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">weight_full</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;stokes&quot;</span><span class="p">:</span>
                <span class="c1"># TODO: Not implemented</span>
                <span class="k">pass</span>

            <span class="c1"># Populate container.</span>
            <span class="n">fbb</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">formed_beam_full</span>

            <span class="c1"># Scale the weights by a factor of 2 to account for the fact that we</span>
            <span class="c1"># have taken the real-component of the fringestopped visibility, which</span>
            <span class="c1"># has a variance that is 1/2 the variance of the complex visibility</span>
            <span class="c1"># that was encoded in our original weight dataset.</span>
            <span class="n">fbw</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">weight_full</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span><span class="p">:</span>
                    <span class="n">formed_beam</span><span class="o">.</span><span class="n">ha</span><span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ha_array</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Populate only where ha_mask is true.</span>
                    <span class="n">formed_beam</span><span class="o">.</span><span class="n">ha</span><span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">ha_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ha_array</span>

        <span class="k">return</span> <span class="n">formed_beam</span></div>

    <span class="k">def</span> <span class="nf">_ha_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">source_ra_index</span><span class="p">,</span> <span class="n">source_ra</span><span class="p">,</span> <span class="n">ha_side</span><span class="p">,</span> <span class="n">is_sstream</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hour angle for each RA/time bin to be processed.</span>

<span class="sd">        Also return the indices of these bins in the full RA/time axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ra : array</span>
<span class="sd">            RA axis in the data</span>
<span class="sd">        source_ra_index : int</span>
<span class="sd">            Index in data.index_map[&#39;ra&#39;] closest to source_ra</span>
<span class="sd">        source_ra : float</span>
<span class="sd">            RA of the quasar</span>
<span class="sd">        ha_side : int</span>
<span class="sd">            Number of RA/HA bins on each side of transit.</span>
<span class="sd">        is_sstream : bool</span>
<span class="sd">            True if data is sidereal stream. Flase if time stream</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ha_array : np.ndarray</span>
<span class="sd">            Hour angle array in the range -180. to 180</span>
<span class="sd">        ra_index_range : np.ndarray of int</span>
<span class="sd">            Indices (in data.index_map[&#39;ra&#39;]) corresponding</span>
<span class="sd">            to ha_array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># RA range to track this quasar through the beam.</span>
        <span class="n">ra_index_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">source_ra_index</span> <span class="o">-</span> <span class="n">ha_side</span><span class="p">,</span> <span class="n">source_ra_index</span> <span class="o">+</span> <span class="n">ha_side</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span>
        <span class="p">)</span>
        <span class="c1"># Number of RA bins in data.</span>
        <span class="n">nra</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_sstream</span><span class="p">:</span>
            <span class="c1"># Wrap RA indices around edges.</span>
            <span class="n">ra_index_range</span><span class="p">[</span><span class="n">ra_index_range</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nra</span>
            <span class="n">ra_index_range</span><span class="p">[</span><span class="n">ra_index_range</span> <span class="o">&gt;=</span> <span class="n">nra</span><span class="p">]</span> <span class="o">-=</span> <span class="n">nra</span>
            <span class="c1"># Hour angle array (convert to radians)</span>
            <span class="n">ha_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="n">ra_index_range</span><span class="p">]</span> <span class="o">-</span> <span class="n">source_ra</span><span class="p">)</span>
            <span class="c1"># For later convenience it is better if `ha_array` is</span>
            <span class="c1"># in the range -pi to pi instead of 0 to 2pi.</span>
            <span class="n">ha_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">ha_array</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="c1"># In this case the ha_mask is trivial</span>
            <span class="n">ha_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ra_index_range</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mask-out indices out of range</span>
            <span class="n">ha_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra_index_range</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ra_index_range</span> <span class="o">&lt;</span> <span class="n">nra</span><span class="p">)</span>
            <span class="c1"># Return smaller HA range, and mask.</span>
            <span class="n">ra_index_range</span> <span class="o">=</span> <span class="n">ra_index_range</span><span class="p">[</span><span class="n">ha_mask</span><span class="p">]</span>
            <span class="c1"># Hour angle array (convert to radians)</span>
            <span class="n">ha_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="n">ra_index_range</span><span class="p">]</span> <span class="o">-</span> <span class="n">source_ra</span><span class="p">)</span>
            <span class="c1"># For later convenience it is better if `ha_array` is</span>
            <span class="c1"># in the range -pi to pi instead of 0 to 2pi.</span>
            <span class="n">ha_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">ha_array</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="k">return</span> <span class="n">ha_array</span><span class="p">,</span> <span class="n">ra_index_range</span><span class="p">,</span> <span class="n">ha_mask</span>

    <span class="k">def</span> <span class="nf">_initialize_beam_with_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Beam initialization that requires data.</span>

<span class="sd">        This is called at the start of the process method</span>
<span class="sd">        and can be overridden to perform any beam initialization</span>
<span class="sd">        that requires the data and catalog to be parsed first.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find the index of the local frequencies in</span>
        <span class="c1"># the frequency axis of the telescope instance</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_beam_model</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">freq_local_telescope_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">frequencies</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span>
                <span class="p">]</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_beamfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the primary beam at the location of a source as it transits.</span>

<span class="sd">        Uses the frequencies in the freq_local_telescope_index attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pol : str</span>
<span class="sd">            String specifying the polarisation,</span>
<span class="sd">            either &#39;XX&#39;, &#39;XY&#39;, &#39;YX&#39;, or &#39;YY&#39;.</span>
<span class="sd">        dec : float</span>
<span class="sd">            The declination of the source in radians.</span>
<span class="sd">        ha : np.ndarray[nha,]</span>
<span class="sd">            The hour angle of the source in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        primary_beam : np.ndarray[nfreq, nha]</span>
<span class="sd">            The primary beam as a function of frequency and hour angle</span>
<span class="sd">            at the sources declination for the requested polarisation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_beam_model</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ha</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">angpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">dec</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ha</span><span class="p">),</span> <span class="n">ha</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">primary_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ha</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ff</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_local_telescope_index</span><span class="p">):</span>

            <span class="n">bii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">beam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pol_feed</span><span class="p">[</span><span class="n">pol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">freq</span><span class="p">,</span> <span class="n">angpos</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pol</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">bjj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">beam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pol_feed</span><span class="p">[</span><span class="n">pol</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">freq</span><span class="p">,</span> <span class="n">angpos</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bjj</span> <span class="o">=</span> <span class="n">bii</span>

            <span class="n">primary_beam</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bii</span> <span class="o">*</span> <span class="n">bjj</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">primary_beam</span>

    <span class="k">def</span> <span class="nf">_process_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store code for parsing and formating data prior to beamforming.&quot;&quot;&quot;</span>
        <span class="c1"># Easy access to communicator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">comm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tag_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;tag&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Extract data info</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">]</span>

            <span class="c1"># Calculate the epoch for the data so we can calculate the correct</span>
            <span class="c1"># CIRS coordinates</span>
            <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;SiderealStream must have an LSD attribute to calculate the epoch.&quot;</span>
                <span class="p">)</span>

            <span class="n">lsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">lsd</span><span class="p">)</span>

            <span class="n">dt</span> <span class="o">=</span> <span class="mf">240.0</span> <span class="o">*</span> <span class="n">ctime</span><span class="o">.</span><span class="n">SIDEREAL_S</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">)))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Convert data timestamps into LSAs (degrees)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">unix_to_lsa</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="c1"># Ensure data is distributed in freq axis</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Number of RA bins to track each source at each side of transit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ha_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timetrack</span> <span class="o">/</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nha</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ha_side</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># polmap: indices of each vis product in</span>
        <span class="c1"># polarization list: [&#39;XX&#39;, &#39;XY&#39;, &#39;YX&#39;, &#39;YY&#39;]</span>
        <span class="n">polmap</span> <span class="o">=</span> <span class="n">polarization_map</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="p">)</span>
        <span class="c1"># Baseline vectors in meters</span>
        <span class="n">bvec_m</span> <span class="o">=</span> <span class="n">baseline_vector</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="p">)</span>

        <span class="c1"># MPI distribution values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ls</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">]</span>

        <span class="c1"># These are to be used when gathering results in the end.</span>
        <span class="c1"># Tuple (not list!) of number of frequencies in each rank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fsize</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">))</span>
        <span class="c1"># Tuple (not list!) of displacements of each rank array in full array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foffset</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="p">))</span>

        <span class="n">fullpol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;YX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
        <span class="c1"># Save subsets of the data for each polarization, changing</span>
        <span class="c1"># the ordering to &#39;C&#39; (needed for the cython part).</span>
        <span class="c1"># This doubles the memory usage.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span><span class="p">:</span>
            <span class="n">pol</span> <span class="o">=</span> <span class="n">fullpol</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span>
            <span class="n">polmask</span> <span class="o">=</span> <span class="n">polmap</span> <span class="o">==</span> <span class="n">pol</span>
            <span class="c1"># Swap order of product(1) and RA(2) axes, to reduce striding</span>
            <span class="c1"># through memory later on.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:,</span> <span class="n">polmask</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Restrict visweight to the local frequencies</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">][:,</span> <span class="n">polmask</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                    <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Multiply bvec_m by frequencies to get vector in wavelengths.</span>
            <span class="c1"># Shape: (2, nfreq_local, nvis), for each pol.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="n">bvec_m</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">polmask</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                    <span class="o">*</span> <span class="mf">1e6</span>
                    <span class="o">/</span> <span class="n">C</span><span class="p">,</span>
                    <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">:</span>
                <span class="c1"># Weights for sum are just the visibility weights</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Ensure zero visweights result in zero sumweights</span>
                <span class="n">this_sumweight</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">ssi</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span>
                <span class="n">ssp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][:]</span>
                <span class="n">sss</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="s2">&quot;stack&quot;</span><span class="p">][:]</span>
                <span class="n">nstack</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># this redundancy takes into account input flags.</span>
                <span class="c1"># It has shape (nstack, ntime)</span>
                <span class="n">redundancy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span>
                    <span class="n">calculate_redundancy</span><span class="p">(</span><span class="n">ssi</span><span class="p">,</span> <span class="n">ssp</span><span class="p">,</span> <span class="n">sss</span><span class="p">,</span> <span class="n">nstack</span><span class="p">)[</span><span class="n">polmask</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                    <span class="p">),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="mi">1</span><span class="p">,</span>
                <span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="c1"># redundancy = (self.telescope.redundancy[polmask].</span>
                <span class="c1">#        astype(np.float64)[np.newaxis, np.newaxis, :])</span>
                <span class="n">this_sumweight</span> <span class="o">*=</span> <span class="n">redundancy</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                    <span class="n">this_sumweight</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_sumweight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">this_sumweight</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_process_catalog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process the catalog to get CIRS coordinates at the correct epoch.</span>

<span class="sd">        Note that `self._process_data` must have been called before this.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;position&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input is missing a position table.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;epoch&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Epoch not set. Was the requested data not available?&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_available</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>

        <span class="n">coord</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;coordinates&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="o">==</span> <span class="s2">&quot;CIRS&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Catalog already in CIRS coordinates.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sra</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sdec</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Converting catalog from ICRS to CIRS coordinates.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdec</span> <span class="o">=</span> <span class="n">icrs_to_cirs</span><span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">],</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input is missing a required redshift table.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span> <span class="o">=</span> <span class="n">NU21</span> <span class="o">/</span> <span class="p">(</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">][:]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># MHz</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span> <span class="o">=</span> <span class="n">catalog</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsource</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tag_catalog</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;tag&quot;</span> <span class="ow">in</span> <span class="n">catalog</span><span class="o">.</span><span class="n">attrs</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="BeamForm"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamForm">[docs]</a><span class="k">class</span> <span class="nc">BeamForm</span><span class="p">(</span><span class="n">BeamFormBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;BeamForm for a single source catalog and multiple visibility datasets.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BeamForm.setup"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamForm.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="n">source_cat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the source catalog and performs the generic setup.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : either `ProductManager`, `BeamTransfer` or `TransitTelescope`</span>
<span class="sd">            Contains a TransitTelescope object describing the telescope.</span>

<span class="sd">        source_cat : :class:`containers.SourceCatalog`</span>
<span class="sd">            Catalog of points to beamform at.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BeamForm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">source_cat</span></div>

<div class="viewcode-block" id="BeamForm.process"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamForm.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the visibility data and beamforms all sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : `containers.SiderealStream` or `containers.TimeStream`</span>
<span class="sd">            Data to beamform on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formed_beam : `containers.FormedBeam` or `containers.FormedBeamHA`</span>
<span class="sd">            Formed beams at each source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Process and make available various data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_catalog</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_available</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Call generic process method.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BeamForm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">process</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="BeamFormCat"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormCat">[docs]</a><span class="k">class</span> <span class="nc">BeamFormCat</span><span class="p">(</span><span class="n">BeamFormBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;BeamForm for multiple source catalogs and a single visibility dataset.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BeamFormCat.setup"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormCat.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the visibility data and performs the generic setup.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : either `ProductManager`, `BeamTransfer` or `TransitTelescope`</span>
<span class="sd">            Contains a TransitTelescope object describing the telescope.</span>

<span class="sd">        data : `containers.SiderealStream` or `containers.TimeStream`</span>
<span class="sd">            Data to beamform on.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BeamFormCat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Process and make available various data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="BeamFormCat.process"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormCat.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_cat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the source catalog and beamforms all sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_cat : :class:`containers.SourceCatalog`</span>
<span class="sd">            Catalog of points to beamform at.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formed_beam : `containers.FormedBeam` or `containers.FormedBeamHA`</span>
<span class="sd">            Formed beams at each source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_catalog</span><span class="p">(</span><span class="n">source_cat</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_available</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Call generic process method.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BeamFormCat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">process</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="BeamFormExternalBase"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormExternalBase">[docs]</a><span class="k">class</span> <span class="nc">BeamFormExternalBase</span><span class="p">(</span><span class="n">BeamFormBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for tasks that beamform using an external model of the primary beam.</span>

<span class="sd">    The primary beam is provided to the task during setup.  Do not use this class</span>
<span class="sd">    directly, instead use BeamFormExternal and BeamFormExternalCat.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BeamFormExternalBase.setup"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormExternalBase.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the beam.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beam : GridBeam</span>
<span class="sd">            Model for the primary beam.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_initialize_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize based on the beam container type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beam : GridBeam</span>
<span class="sd">            Container holding the model for the primary beam.</span>
<span class="sd">            Currently only accepts GridBeam type containers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">GridBeam</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_grid_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_beamfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_beam</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Do not recognize beam container: </span><span class="si">{</span><span class="n">beam</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_beam_with_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure that the beam and visibilities have the same frequency axis.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beam_freq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Beam and visibility frequency axes do not match.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_grid_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gbeam</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an interpolator for a GridBeam.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gbeam : GridBeam</span>
<span class="sd">            Model for the primary beam on a celestial grid where</span>
<span class="sd">            (theta, phi) = (declination, hour angle) in degrees.  The beam</span>
<span class="sd">            must be in power units and must have a length 1 input axis that</span>
<span class="sd">            contains the &quot;baseline averaged&quot; beam, which will be applied to</span>
<span class="sd">            all baselines of a given polarisation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Make sure the beam is in celestial coordinates</span>
        <span class="k">if</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">coords</span> <span class="o">!=</span> <span class="s2">&quot;celestial&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;GridBeam must be converted to celestial coordinates for beamforming.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Make sure there is a single beam to use for all inputs</span>
        <span class="k">if</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Do not support input-dependent beams at the moment.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Distribute over frequencies, extract local frequencies</span>
        <span class="n">gbeam</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">lo</span> <span class="o">=</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beam_freq</span> <span class="o">=</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">lo</span> <span class="p">:</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">nfreq</span><span class="p">]</span>

        <span class="c1"># Find the relevant indices into the polarisation axis</span>
        <span class="n">ipol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">gbeam</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pstr</span><span class="p">)</span> <span class="k">for</span> <span class="n">pstr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span><span class="p">])</span>
        <span class="n">npol</span> <span class="o">=</span> <span class="n">ipol</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beam_pol</span> <span class="o">=</span> <span class="p">[</span><span class="n">gbeam</span><span class="o">.</span><span class="n">pol</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">ipol</span><span class="p">]</span>

        <span class="c1"># Extract beam</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="n">ipol</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="n">ipol</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Convert the declination and hour angle axis to radians, make sure they are sorted</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="p">(</span><span class="n">gbeam</span><span class="o">.</span><span class="n">phi</span> <span class="o">+</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span> <span class="o">-</span> <span class="mf">180.0</span>
        <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ha</span><span class="p">[</span><span class="n">isort</span><span class="p">])</span>

        <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">gbeam</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>

        <span class="c1"># Create a 2D interpolator for the beam at each frequency and polarisation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beam</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">,</span> <span class="n">beam</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">pp</span><span class="p">][:,</span> <span class="n">isort</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Create a similair interpolator for the flag array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beam_flag</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">,</span> <span class="n">flag</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">pp</span><span class="p">][:,</span> <span class="n">isort</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Grid beam initialized.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_grid_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate a GridBeam to the requested declination and hour angles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pol : str</span>
<span class="sd">            String specifying the polarisation,</span>
<span class="sd">            either &#39;XX&#39;, &#39;XY&#39;, &#39;YX&#39;, or &#39;YY&#39;.</span>
<span class="sd">        dec : float</span>
<span class="sd">            The declination of the source in radians.</span>
<span class="sd">        ha : np.ndarray[nha,]</span>
<span class="sd">            The hour angle of the source in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        primay_beam : np.ndarray[nfreq, nha]</span>
<span class="sd">            The primary beam as a function of frequency and hour angle</span>
<span class="sd">            at the sources declination for the requested polarisation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beam_pol</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span>

        <span class="n">primay_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_beam</span><span class="p">[</span><span class="n">ff</span><span class="p">][</span><span class="n">pp</span><span class="p">](</span><span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beam_freq</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="c1"># If the interpolated flags deviate from 1.0, then we mask</span>
        <span class="c1"># the interpolated beam, since some fraction the underlying</span>
        <span class="c1"># data used to construct the interpolator was masked.</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beam_flag</span><span class="p">[</span><span class="n">ff</span><span class="p">][</span><span class="n">pp</span><span class="p">](</span><span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span>
                <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beam_freq</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">primay_beam</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span></div>


<div class="viewcode-block" id="BeamFormExternal"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormExternal">[docs]</a><span class="k">class</span> <span class="nc">BeamFormExternal</span><span class="p">(</span><span class="n">BeamFormExternalBase</span><span class="p">,</span> <span class="n">BeamForm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Beamform a single catalog and multiple datasets using an external beam model.</span>

<span class="sd">    The setup method requires [beam, manager, source_cat] as arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BeamFormExternalCat"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormExternalCat">[docs]</a><span class="k">class</span> <span class="nc">BeamFormExternalCat</span><span class="p">(</span><span class="n">BeamFormExternalBase</span><span class="p">,</span> <span class="n">BeamFormCat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Beamform multiple catalogs and a single dataset using an external beam model.</span>

<span class="sd">    The setup method requires [beam, manager, data] as arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="RingMapBeamForm"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapBeamForm">[docs]</a><span class="k">class</span> <span class="nc">RingMapBeamForm</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Beamform by extracting the pixel containing each source form a RingMap.</span>

<span class="sd">    This is significantly faster than `Beamform` or `BeamformCat` with the caveat</span>
<span class="sd">    that they can beamform exactly on a source whereas this task is at the mercy of</span>
<span class="sd">    what was done to produce the `RingMap` (use `DeconvolveHybridM` for best</span>
<span class="sd">    results).</span>

<span class="sd">    Unless it has an explicit `lsd` attribute, the ring map is assumed to be in the</span>
<span class="sd">    same coordinate epoch as the catalog. If it does, the input catalog is assumed to be</span>
<span class="sd">    in ICRS and then is precessed to the CIRS coordinates in the epoch of the map.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RingMapBeamForm.setup"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapBeamForm.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="p">:</span> <span class="n">io</span><span class="o">.</span><span class="n">TelescopeConvertible</span><span class="p">,</span> <span class="n">ringmap</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the telescope object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager</span>
<span class="sd">            The telescope object to use.</span>
<span class="sd">        ringmap</span>
<span class="sd">            The ringmap to extract the sources from. See the class documentation for how</span>
<span class="sd">            the epoch is determined.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span> <span class="o">=</span> <span class="n">ringmap</span></div>

<div class="viewcode-block" id="RingMapBeamForm.process"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapBeamForm.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SourceCatalog</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extract sources from a ringmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        catalog</span>
<span class="sd">            The catalog to extract sources from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sources</span>
<span class="sd">            The source spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ringmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span>

        <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_catalog</span><span class="p">(</span><span class="n">catalog</span><span class="p">)</span>

        <span class="c1"># Container to hold the formed beams</span>
        <span class="n">formed_beam</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">(</span>
            <span class="n">object_id</span><span class="o">=</span><span class="n">catalog</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;object_id&quot;</span><span class="p">],</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">ringmap</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">catalog</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialize container to zeros.</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy catalog information</span>
        <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span>
        <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span>

        <span class="c1"># Ensure containers are distributed in frequency</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">ringmap</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">has_weight</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">datasets</span>

        <span class="c1"># Get the pixel indices</span>
        <span class="n">ra_ind</span><span class="p">,</span> <span class="n">za_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_ind</span><span class="p">(</span><span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">)</span>

        <span class="c1"># Dereference the datasets</span>
        <span class="n">fbb</span> <span class="o">=</span> <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span>
        <span class="n">fbw</span> <span class="o">=</span> <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>
        <span class="n">rmm</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">map</span><span class="p">[:]</span>
        <span class="n">rmw</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">has_weight</span> <span class="k">else</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">rms</span><span class="p">[:])</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># Loop over sources and extract the polarised pencil beams containing them from</span>
        <span class="c1"># the ringmaps</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ra_ind</span><span class="p">,</span> <span class="n">za_ind</span><span class="p">)):</span>
            <span class="n">fbb</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">ri</span><span class="p">,</span> <span class="n">zi</span><span class="p">]</span>
            <span class="n">fbw</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmw</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ri</span><span class="p">,</span> <span class="n">zi</span><span class="p">]</span> <span class="k">if</span> <span class="n">has_weight</span> <span class="k">else</span> <span class="n">rmw</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ri</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">formed_beam</span></div>

    <span class="k">def</span> <span class="nf">_process_catalog</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SourceCatalog</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get the current epoch coordinates of the catalog.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;position&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input is missing a position table.&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate the epoch for the data so we can calculate the correct</span>
        <span class="c1"># CIRS coordinates</span>
        <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Input map has no epoch set, assuming that it matches the catalog.&quot;</span>
            <span class="p">)</span>
            <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">],</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">lsd</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">lsd</span><span class="p">)</span>

            <span class="c1"># Get the source positions at the current epoch</span>
            <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="n">icrs_to_cirs</span><span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">],</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">],</span> <span class="n">epoch</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span>

    <span class="k">def</span> <span class="nf">_source_ind</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">src_ra</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get the RA/ZA ringmap pixel indices of the sources.&quot;&quot;&quot;</span>

        <span class="c1"># Get the grid size of the map in RA and sin(ZA)</span>
        <span class="n">dra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">])))</span>
        <span class="n">dza</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;el&quot;</span><span class="p">])))</span>
        <span class="n">za_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;el&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="c1"># Get the source indices in RA</span>
        <span class="c1"># NOTE: that we need to take into account that sources might be less than 360</span>
        <span class="c1"># deg, but still closer to ind=0</span>
        <span class="n">max_ra_ind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">ra</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">ra_ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">src_ra</span> <span class="o">/</span> <span class="n">dra</span><span class="p">)</span> <span class="o">%</span> <span class="n">max_ra_ind</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="c1"># Get the indices for the ZA direction</span>
        <span class="n">za_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_dec</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">latitude</span><span class="p">))</span> <span class="o">-</span> <span class="n">za_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">dza</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ra_ind</span><span class="p">,</span> <span class="n">za_ind</span></div>


<div class="viewcode-block" id="RingMapStack2D"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapStack2D">[docs]</a><span class="k">class</span> <span class="nc">RingMapStack2D</span><span class="p">(</span><span class="n">RingMapBeamForm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stack RingMap&#39;s on sources directly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_ra, num_dec : int</span>
<span class="sd">        The number of RA and DEC pixels to stack either side of the source.</span>
<span class="sd">    num_freq : int</span>
<span class="sd">        Number of final frequency channels either side of the source redshift to</span>
<span class="sd">        stack.</span>
<span class="sd">    freq_width : float</span>
<span class="sd">        Length of frequency interval either side of source to use in MHz.</span>
<span class="sd">    weight : {&quot;patch&quot;, &quot;dec&quot;, &quot;enum&quot;}</span>
<span class="sd">        How to weight the data. If `&quot;input&quot;` the data is weighted on a pixel by pixel</span>
<span class="sd">        basis according to the input data. If `&quot;patch&quot;` then the inverse of the</span>
<span class="sd">        variance of the extracted patch is used. If `&quot;dec&quot;` then the inverse variance</span>
<span class="sd">        of each declination strip is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_ra</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">num_dec</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">num_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
    <span class="n">freq_width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">100.0</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="s2">&quot;dec&quot;</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="RingMapStack2D.process"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapStack2D.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SourceCatalog</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extract sources from a ringmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        catalog</span>
<span class="sd">            The catalog to extract sources from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sources</span>
<span class="sd">            The source spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>

        <span class="n">ringmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span>

        <span class="c1"># Get the current epoch catalog position</span>
        <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_catalog</span><span class="p">(</span><span class="n">catalog</span><span class="p">)</span>
        <span class="n">src_z</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">]</span>

        <span class="c1"># Get the pixel indices</span>
        <span class="n">ra_ind</span><span class="p">,</span> <span class="n">za_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_ind</span><span class="p">(</span><span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">)</span>

        <span class="c1"># Ensure containers are distributed in frequency</span>
        <span class="n">ringmap</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get the frequencies on this rank</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">fe</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">+</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">local_freq</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">fs</span><span class="p">:</span><span class="n">fe</span><span class="p">]</span>

        <span class="c1"># Dereference the datasets</span>
        <span class="n">rmm</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">map</span><span class="p">[:]</span>
        <span class="n">rmw</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ringmap</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>
            <span class="k">if</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">datasets</span>
            <span class="k">else</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">rms</span><span class="p">[:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the frequencies bins to use</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_freq</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_width</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the edges of the frequency distribution, sources outside this range</span>
        <span class="c1"># will be dropped</span>
        <span class="n">global_fmin</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">global_fmax</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># Create temporary array to accumulate into</span>
        <span class="n">wstack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nbins</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">pol</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nbins</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">pol</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">rmvar</span> <span class="o">=</span> <span class="n">rmm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">w_global</span> <span class="o">=</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rmvar</span> <span class="o">&lt;</span> <span class="mf">3e-7</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">rmvar</span><span class="p">))</span>

        <span class="c1"># Loop over sources and extract the polarised pencil beams containing them from</span>
        <span class="c1"># the ringmaps</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ra_ind</span><span class="p">,</span> <span class="n">za_ind</span><span class="p">,</span> <span class="n">src_z</span><span class="p">)):</span>
            <span class="n">source_freq</span> <span class="o">=</span> <span class="mf">1420.406</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">source_freq</span> <span class="o">&gt;</span> <span class="n">global_fmax</span> <span class="ow">or</span> <span class="n">source_freq</span> <span class="o">&lt;</span> <span class="n">global_fmin</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get bin indices</span>
            <span class="n">bin_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">local_freq</span> <span class="o">-</span> <span class="n">source_freq</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">)</span>

            <span class="c1"># Get the slices to extract the enclosing angular region</span>
            <span class="n">ri_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ri</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span><span class="p">,</span> <span class="n">ri</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">zi_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">zi</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span><span class="p">,</span> <span class="n">zi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">b</span> <span class="o">=</span> <span class="n">rmm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">ri_slice</span><span class="p">,</span> <span class="n">zi_slice</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">rmw</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ri_slice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;patch&quot;</span><span class="p">:</span>
                <span class="c1"># Replace the weights with the variance of the patch</span>
                <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))[</span>
                    <span class="p">:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
                <span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;dec&quot;</span><span class="p">:</span>
                <span class="c1"># w = (w != 0) * invert_no_zero(b.var(axis=2))[:, :, np.newaxis, :]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">w_global</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">zi_slice</span><span class="p">]</span>

            <span class="n">bw</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">w</span>

            <span class="c1"># TODO: this is probably slow so should be moved into Cython</span>
            <span class="k">for</span> <span class="n">lfi</span><span class="p">,</span> <span class="n">bi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bin_ind</span><span class="p">):</span>
                <span class="n">wstack</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bw</span><span class="p">[:,</span> <span class="n">lfi</span><span class="p">]</span>
                <span class="n">weight</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">lfi</span><span class="p">]</span>

        <span class="c1"># Arrays to reduce the data into</span>
        <span class="n">wstack_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">wstack</span><span class="p">)</span>
        <span class="n">weight_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">wstack</span><span class="p">,</span> <span class="n">wstack_all</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">weight_all</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>

        <span class="n">stack_all</span> <span class="o">=</span> <span class="n">wstack_all</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight_all</span><span class="p">)</span>

        <span class="c1"># Create the container to store the data in</span>
        <span class="n">bin_centres</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">Stack3D</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">bin_centres</span><span class="p">,</span>
            <span class="n">delta_ra</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">delta_dec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">ringmap</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">ringmap</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">stack</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">stack_all</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">stack</span></div></div>


<div class="viewcode-block" id="HealpixBeamForm"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.HealpixBeamForm">[docs]</a><span class="k">class</span> <span class="nc">HealpixBeamForm</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Beamform by extracting the pixel containing each source form a Healpix map.</span>

<span class="sd">    Unless it has an explicit `epoch` attribute, the Healpix map is assumed to be in the</span>
<span class="sd">    same coordinate epoch as the catalog. If it does, the input catalog is assumed to be</span>
<span class="sd">    in ICRS and then is precessed to the CIRS coordinates in the epoch of the map.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fwhm : float</span>
<span class="sd">        Smooth the map with a Gaussian with the specified FWHM in degrees. If `None`</span>
<span class="sd">        (default), leave at native map resolution. This will modify the input map in</span>
<span class="sd">        place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fwhm</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="HealpixBeamForm.setup"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.HealpixBeamForm.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hpmap</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">Map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the map to extract beams from at each catalog location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hpmap</span>
<span class="sd">            The Healpix map to extract the sources from.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">hpmap</span>
        <span class="n">mv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">map</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Smoothing input Healpix map.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lfi</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">mv</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">mv</span><span class="p">[</span><span class="n">lfi</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">healpy</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span>
                    <span class="n">mv</span><span class="p">[</span><span class="n">lfi</span><span class="p">,</span> <span class="n">pi</span><span class="p">],</span> <span class="n">fwhm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="HealpixBeamForm.process"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.HealpixBeamForm.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SourceCatalog</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extract sources from a ringmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        catalog</span>
<span class="sd">            The catalog to extract sources from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formed_beam</span>
<span class="sd">            The source spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;position&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input is missing a position table.&quot;</span><span class="p">)</span>

        <span class="c1"># Container to hold the formed beams</span>
        <span class="n">formed_beam</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">(</span>
            <span class="n">object_id</span><span class="o">=</span><span class="n">catalog</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;object_id&quot;</span><span class="p">],</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialize container to zeros.</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy catalog information</span>
        <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span>
        <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span>

        <span class="c1"># Get the source positions at the epoch of the input map</span>
        <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">epoch</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span> <span class="k">if</span> <span class="n">epoch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="p">:</span>
            <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="n">icrs_to_cirs</span><span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">],</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">],</span> <span class="n">epoch</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Input map has no epoch set, assuming that it matches the catalog.&quot;</span>
            <span class="p">)</span>
            <span class="n">src_ra</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">]</span>
            <span class="n">src_dec</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">]</span>

        <span class="c1"># Use Healpix to get the pixels containing the sources</span>
        <span class="n">pix_ind</span> <span class="o">=</span> <span class="n">healpy</span><span class="o">.</span><span class="n">ang2pix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">,</span> <span class="n">lonlat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Ensure containers are distributed in frequency</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">map</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pix_ind</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Set to some non-zero value as the Map container doesn&#39;t have a weight</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">formed_beam</span></div></div>


<div class="viewcode-block" id="icrs_to_cirs"><a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.icrs_to_cirs">[docs]</a><span class="k">def</span> <span class="nf">icrs_to_cirs</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">apparent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a set of positions from ICRS to CIRS at a given data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ra, dec : float or np.ndarray</span>
<span class="sd">        Positions of source in ICRS coordinates including an optional</span>
<span class="sd">        redshift position.</span>
<span class="sd">    epoch : time_like</span>
<span class="sd">        Time to convert the positions to. Can be any type convertible to a</span>
<span class="sd">        time using `caput.time.ensure_unix`.</span>
<span class="sd">    apparent : bool</span>
<span class="sd">        Calculate the apparent position (includes abberation and deflection).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ra_cirs, dec_cirs : float or np.ndarray</span>
<span class="sd">        Arrays of the positions in *CIRS* coordiantes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">Star</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="n">Angle</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="n">ra</span><span class="p">),</span> <span class="n">dec</span><span class="o">=</span><span class="n">Angle</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="n">dec</span><span class="p">))</span>

    <span class="n">epoch</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">unix_to_skyfield_time</span><span class="p">(</span><span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">epoch</span><span class="p">))</span>

    <span class="n">earth</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">skyfield_wrapper</span><span class="o">.</span><span class="n">ephemeris</span><span class="p">[</span><span class="s2">&quot;earth&quot;</span><span class="p">]</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">earth</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">apparent</span><span class="p">:</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">apparent</span><span class="p">()</span>

    <span class="n">ra_cirs</span><span class="p">,</span> <span class="n">dec_cirs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">cirs_radec</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ra_cirs</span><span class="o">.</span><span class="n">_degrees</span><span class="p">,</span> <span class="n">dec_cirs</span><span class="o">.</span><span class="n">_degrees</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Richard Shaw.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>